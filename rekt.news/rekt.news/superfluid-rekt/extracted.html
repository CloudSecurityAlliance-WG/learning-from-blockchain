<section class="post-content"><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2022/02/superfluid-header.png"/></figure></p><p><strong>$8.7M drained from Superfluid.</strong></p><p><em>The crypto streaming protocol was hacked at 06:17 +UTC 08/02/22.</em></p><p>Other projects who were using the service for contributor payments or investor escrow contracts suffered negative price impacts as the attacker dumped their native tokens.</p><p>The affected protocols included Mai Finance <a href="https://www.coingecko.com/en/coins/qi-dao">(QI)</a>, Stacker Ventures <a href="https://www.coingecko.com/en/coins/stackos">(STACK)</a>, Stake DAO <a href="https://www.coingecko.com/en/coins/stake-dao">(SDT)</a>, and Museum of Crypto Art <a href="https://www.coingecko.com/en/coins/museum-of-crypto-art">(MOCA)</a>.</p><p>QI was the worst affected token, dropping initially by almost 80% following the dump, but it has since recovered to ~62% of its pre-hack price.</p><p>Superfluid’s <a href="https://twitter.com/francescorenzia">@francescorenzia</a> told rekt.news that the attack was focussed only on the platform’s larger wallet balances. In the time before the vulnerability was patched, the hacker left plenty of ETH, USDC and DAI untouched, presumably because the attacker had “<em>had enough</em>”.</p><p><em>How did it happen?</em></p><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2021/09/rekt-investigates-linebreak.png"/></figure></p><p><strong>Attacker’s address:</strong> <a href="https://polygonscan.com/address/0x1574f7f4c9d3aca2ebce918e5d19d18ae853c090">0x1574f7f4c9d3aca2ebce918e5d19d18ae853c090</a></p><p><strong>Exploit tx:</strong> <a href="https://polygonscan.com/tx/0xdee86cae2e1bab16496a49b2ec61aae0472a7ccf06f79744d42473e96edd6af6">0xdee86cae2e1bab16496a49…</a></p><p><strong>Assets taken:</strong></p><p>19.4M QI (pre-hack value of $24M) <a href="https://polygonscan.com/tx/0xc37151aaefa7e937c97156ca43e3d486299aa89a603d22355592ddd00bfe687a">sold</a> <a href="https://polygonscan.com/tx/0x741908f9707d9dd3a52525380d69f9e74a26d52350308227b84c3ad2db45449f">in</a> <a href="https://polygonscan.com/tx/0x026032084b3f7c658b7c3467d8567922e3ad93c755669ab0d92f01f040a18dea">four</a> <a href="https://polygonscan.com/tx/0x8dd5e00a54742f182eee7277a3326efd434f893fd94f5473f9ca1f0fd0358577">transactions</a> for a total of 2.3k WETH (~$6.2M)</p><p>24.4 WETH - (~$76k)</p><p>563k USDC <a href="https://polygonscan.com/tx/0x9fdbcaefcd2bae1d873720ae8dfb741986818bfc1b5cf8af0a891b99b7bd14b1">sold for 173 WETH</a></p><p>45k SDT - <a href="https://polygonscan.com/tx/0xd12c38ce2346bbc29a845dd9099a8d3626ad12e74579be46485e31653a3888bc">sold for ~17 WETH</a> - (~$54k)</p><p>24k STACK - <a href="https://polygonscan.com/tx/0x32df8bbeba3a8fcdba51c2a7daa316078cd65345a74b765b8fa2ce6787c91f28">sold for ~6.2 WETH</a> - (~$19k)</p><p>39k sdam3CRV - Swapped to <a href="https://polygonscan.com/tx/0x0553be6c6f969c4f91850532f68f4e8bae5824392140edb13c3bfd6f6cb8d35e">am3CRV</a>, then to ~44k <a href="https://polygonscan.com/tx/0x7a9b9ad4634fea8681e34c150ef561bf0ced199a3347888dfc448e4164583f7d">amDAI</a></p><p>1.5M MOCA - <a href="https://polygonscan.com/tx/0x554f5688fb8d31bcd9affc90d16f0326a8d09b0469dbb581580c7187201ef6ba">1M of 1.5M sold</a> for 173 WETH (~$500K)</p><p>11k MATIC - Not yet sold</p><blockquote><p>Total - ~$8.7M</p></blockquote><p><strong>~6 hours after the attack, Superfluid patched the bug with help from <a href="https://twitter.com/Mudit__Gupta">Mudit Gupta.</a></strong></p><p><em><a href="https://github.com/superfluid-finance/protocol-monorepo/commit/4048fbc66c144e1afd5ae68b21160e1b25d96270">The patch can be found here.</a></em></p><blockquote><p>The text below is taken from <a href="https://medium.com/superfluid-blog/08-02-22-exploit-post-mortem-15ff9c97cdd">Superfluid’s own post-mortem.</a></p></blockquote><p><strong>Vulnerability Explanation</strong></p><p>Superfluid.sol, known as the host contract, is the contract that allows composable Superfluid agreements <em>(ConstantFlowAgreement, InstantDistributionAgreement)</em> in one single transaction, and the composed systems are often called Super Apps.</p><p>However, in order to have a trusted and shared state through the entire transaction between different agreement calls, a concept called <em>“ctx”</em> (a serialized state managed by the host contract) is introduced.</p><p>The “ctx” contains all the context an agreement function needs to know, that includes especially who is the <em>“msg.sender”</em> of the initial call.</p><p>That’s where an unfortunate vulnerability was exploited.</p><p><strong>The attacker was able to skillfully craft the calldata such that the process of serialization in the host contract and succeeding de-serialization in the agreement contract resulted in the agreement contract operating on a context object forged specifically to impersonate other accounts.</strong></p><p>This mechanism was used in order to create IDA indexes “on behalf” of other accounts and move out their tokens that way.</p><p><strong>The Exploiter Contract:</strong></p><p>The following exploiter contract demonstrates how the vulnerability could be used to impersonate other accounts to close their open streams.</p><p>In the actual <a href="https://polygonscan.com/tx/0x396b6ee91216cf6e7c89f0c6044dfc97e84647f5007a658ca899040471ab4d67">exploit transaction</a>, the attacker used the IDA contract to drain funds from other accounts using the same technique:</p><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2022/02/superfluid-badcall-code.png"/></figure></p><p><strong>Chain of Function Calls</strong></p><p><strong>deleteAnyFlowBad</strong></p><p>The convention to callAgreement is to use the placeholder ctx, so that later agreement solidity code can read it directly as an argument “ctx”.</p><p><em>To read more about this concept, see <a href="https://github.com/superfluid-finance/protocol-monorepo/wiki/About-Placeholder-Ctx">About-Placeholder-Ctx</a>.</em></p><p>This is where the attacker managed to inject a faked “ctx”, where an arbitrary sender could be set.</p><p><strong>Superfluid.callAgreement</strong></p><p>In the normal case, Superfluid.callAgreement creates the ctx and puts a stamp on it (stores its hash in a state variable), such that it can be validated using <em>Superfluid.isCtxValid.</em></p><p><strong>ConstantFlowAgreementV1.createFlow</strong></p><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2022/02/superfluid-createflow-code.png"/></figure></p><p>The agreement then uses AgreementLibrary.authorizeTokenAccess to verify that the calling host contract is authorized to do state modifying calls on the token contract.</p><p><strong>AgreementLibrary.authorizeTokenAccess</strong></p><p>Once the calling host is authenticated, the agreement would transitively also trust the handed over ctx and decode (de-serialize) it into a memory structure.</p><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2022/02/superfluid-authorize-code.png"/></figure></p><p><strong>But Fake Ctx!</strong></p><p>The problem was that as in the exploiting function <em>deleteAnyFlowBad</em>, one can inject a fake ctx.</p><p>After being merged into one bytes object by <em>Superfluid.replacePlaceholderCtx</em> (the Host doesn’t make any assumptions about agreement specific data), the resulting <em>dataWithCtx</em> now contains 2 ctx variants, the legitimate one and the injected one.</p><p><strong>When the agreement contract decodes this data, the abi decoder takes the first (injected) variant and ignores the remaining data which contains the legitimate ctx.</strong></p><p>In order to solve this, Superfluid added a verification step in the agreement contract:</p><p><em>ISuperfluid.isCtxValid.</em> This verifies the decoded ctx by comparing its stamp (hash) stored in the host contract.</p><p>This check was already in place for handling ctx data provided by SuperApp callbacks, but was not in place for data handed over by the trusted Host contract.</p><p><figure><img alt="" src="https://raw.githubusercontent.com/RektHQ/Assets/main/images/2021/03/rekt-linebreak.png"/></figure></p><p><strong>Superfluid has reached out to the attacker <a href="https://polygonscan.com/tx/0x5f9fd626df2fcfef5899c10cea2ec329e76dc0d4350b4c8cf28ce776785e1952">on-chain</a> and, according to the post-mortem, a $1M bounty remains on the table in exchange for the return of the funds.</strong></p><p>The team also states that most of the affected accounts have already been refunded, while the larger QI and MOCA losses will be compensated more gradually.</p><p>Although this was not the largest exploit <em>(number 42 on <a href="https://rekt.news/leaderboard/">our leaderboard</a>)</em>, and no user funds were lost, it is notable for the manner in which it affected other protocols.</p><p>The growing area of DAO infrastructure presents more targets for the anonymous attackers who are so prevalent in DeFi.</p><p><strong>The stolen money still sits in the attackers wallet.</strong></p><p><em>Will they take the bounty, or leave Superfluid high and dry?</em></p>