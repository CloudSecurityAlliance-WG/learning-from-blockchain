File Name,Status,Message,Key Vulnerabilities
abra-rekt,SUCCESS," Based on the details provided, the root cause of the exploit was a rounding error vulnerability in the CauldronV4 contracts used by Abracadabra. Specifically:  The borrow function was vulnerable to manipulation of the ""part"" parameter (the user's share of total debt) by repeatedly borrowing and repaying an asset. This took advantage of a rounding error that allowed the attacker to incorrectly calculate their debt.  This enabled the attacker to:  1. Flash loan MIM tokens 2. Deposit MIM tokens into BentoBox to enable the ERC-4626 ""first depositor"" vulnerability 3. Repay liabilities for other users 4. Repeatedly borrow and repay to inflate the share price (the ERC-4626 vulnerability) 5. Add collateral and borrow a large amount of MIM 6. Repay the flash loan and take profits  The resulting MIM dump by the attacker caused the depegging event.  In summary, the attack combined flash loans, manipulation of the ""part"" parameter via a rounding vulnerability, and ERC-4626 vulnerabilities to steal funds. The technical details provided give a clear picture of how the attack was executed.",Rounding error in borrow function allowing debt manipulation; ERC-4626 first depositor vulnerability
agave-hundred-rekt,SUCCESS," Based on the details provided, it seems the vulnerability that enabled the attacks was a reentrancy vulnerability due to the design of the xDAI token, which contains the function callAfterTransfer().  Specifically:  - The xDAI token has a callAfterTransfer() function that allows reentrancy. This created a vulnerability in the lending protocols Agave and Hundred Finance that are built on the xDAI chain.  - The attacker exploited this by using flash loans to borrow assets repeatedly in a nested way before the protocols could update balances, essentially draining funds. This is similar to the reentrancy attack on Cream Finance mentioned.  - The post mortems highlight that even if you fork/copy strong code from established projects like Aave and Compound, new vulnerabilities can emerge in different environments. Key lessons being strict input vetting, following checks-effects-interactions coding patterns, and extensive auditing when bringing code to new chains.  So in summary, the root cause was the reentrancy vulnerability due to the callAfterTransfer() function in the xDAI token, which enabled the flash loan attacks on the lending protocols. The write-up has good technical detail on the specific attack flow.",Reentrancy vulnerability in xDAI token's callAfterTransfer() function enabling flash loan attacks
akropolis-rekt,SUCCESS," Based on the details provided, the attacker exploited a reentrancy vulnerability in the Akropolis protocol to steal $2 million in DAI tokens. Specifically:  1. The attacker created a malicious ERC-20 token contract.  2. They deposited this malicious token into the Akropolis protocol.  3. The deposit triggered a callback to the malicious token contract.  4. The callback reentered the Akropolis deposit function to make another deposit of 25k DAI tokens, supplied via a flash loan.  5. Because of the reentrant call, the Akropolis protocol incorrectly calculated the deposit amount and credited the attacker for 50k DAI instead of 25k.  6. The attacker withdrew the extra 25k DAI.  This attack relied on reentrancy - the ability of a contract to call back into the calling contract before the first invocation completes. This allowed the attacker to manipulate the deposit amount calculation. The flash loan provided the capital needed to deposit and exploit the vulnerability.  The key pieces of information that allowed me to determine this are:  - Mention of ""re-entrancy"" - The deposit amount being calculated as the difference before and after - The attack contract making an additional deposit via callback - Withdrawing double the actual deposit amount  So in summary, this was a reentrancy attack using a malicious token contract and flash loan. The details provided are sufficient to determine how it was executed.",Reentrancy vulnerability allowing callback from malicious token to manipulate deposit amount calculation
au-dodo-rekt,SUCCESS," Based on the details provided, the attacker exploited a vulnerability in the DODO V2 Crowdpooling smart contract that allows the init() function to be called multiple times. Here are the key steps the attacker took:  1. The attacker created a fake token and initialized the smart contract with it by calling init().  2. The attacker called sync() to set the token balance to 0.  3. The attacker called init() again, this time with a real token from DODO's pools.  4. The attacker used a flash loan to drain all the real tokens from the pools and bypass the flash loan check.  The ability to call init() multiple times allowed the attacker to trick the contract into thinking the fake token was legitimate, then replace it with a real token and drain the pools. This was possible due to the contract not preventing multiple init() calls.  In summary, the vulnerability was the lack of validation around init() being called multiple times, which allowed the attacker to manipulate token balances and drain funds.",Lack of validation preventing multiple calls to init() function enabling token balance manipulation
audius-rekt,SUCCESS," Based on the details provided, the vulnerability that allowed the attacker to execute this attack was:  The attacker was able to take control of the Audius governance contract by exploiting a known issue with storage collisions between the AudiusAdminUpgradabilityProxy contract and the OpenZeppelin Initializable contract.  Specifically:  - The AudiusAdminUpgradabilityProxy contract sets the proxyAdmin address in storage slot 0.  - This creates a collision with the Initializable contract, which also uses storage slot 0.  - This allowed the attacker to reinitialize the Audius governance contract and take control of it by setting themself as the new admin.  - Once in control of the governance contract, the attacker could change parameters and increase their own voting power.  - They then used their increased voting power to pass a malicious proposal that transferred 18M AUDIO tokens from the treasury to their own address.  In summary, the vulnerability was a known storage collision issue that allowed the attacker to take control of the Audius governance contract and exploit it to steal funds.",Storage collision between AudiusAdminUpgradabilityProxy and Initializable contracts allowing takeover of governance
autoshark-rekt,SUCCESS," Based on the details provided, the attacker exploited a vulnerability in the Autoshark protocol's reward minting mechanism. Specifically:  1. The attacker made a small deposit into the SHARK-BNB vault to establish a position.  2. They took out a large (100K BNB) flash loan from Pancakeswap.  3. They used 50K BNB from the flash loan to buy SHARK tokens, and sent the SHARK + remaining 50K BNB to the SharkMinter contract.  4. They called the getReward function on the SharkMinter contract with their deposit from step 1.  5. Because the SharkMinter contract saw a huge SHARK and BNB balance (from step 3), it incorrectly calculated an extremely large profit amount and minted 100M new SHARK tokens as a reward.  6. The attacker dumped the minted SHARK tokens to repay the flash loan.  In summary, the vulnerability allowed an attacker to artificially inflate the reward calculation by sending assets directly to the minter contract to manipulate its balance. This resulted in an excessive number of new SHARK tokens being minted as reward. There are enough technical details provided to determine the attack vector.",Vulnerable reward calculation logic allowing inflation of minter contract balance to mint excess rewards
badger-rekt,SUCCESS," Based on the details provided, it seems the attacker compromised Badger DAO's front-end to insert additional token approvals that allowed the attacker to later drain user funds. Specifically:  - The attacker was able to manipulate Badger's front-end to show unusual token approvals when users attempted legitimate transactions like deposits and reward claims.  - These approvals allowed the attacker to increase their allowance to spend user tokens. Over 500 user addresses approved the attacker's address, granting them unlimited access to funds.  - Armed with these approvals, the attacker was then able to drain user funds, stealing $120 million in various coins. They transferred tokens directly from user wallets.  - An example transaction shows the attacker draining ~900 byvWBTC (worth over $50M) from a user that had approved the attacker's address to spend unlimited tokens just hours earlier.  So in summary, the attacker focused on compromising Badger's front-end to trick users into unknowingly granting broad token approvals, which enabled the theft. The front-end manipulation went undetected for at least 12 days. This highlights the need for projects to aggressively monitor for unauthorized changes to critical infrastructure like front-end code.",Front-end compromise allowing insertion of malicious token approvals that enabled later user funds theft
beanstalk-rekt,SUCCESS," Based on the details provided, the main vulnerability the attacker exploited was the ability to instantly execute a malicious governance proposal without any delay. Specifically:  1) The attacker prepared a malicious governance proposal (BIP-18) that would transfer all funds from the protocol to the attacker. This was made possible by the 1 day delay on governance actions, which allowed the proposal to be prepared in advance.  2) The attacker then used a flash loan to temporarily gain a majority of voting power in the protocol. This flash loan provided over $1 billion worth of assets that were added to liquidity pools with BEAN tokens to gain voting power.  3) With the temporary voting power, the attacker voted on and instantly executed the prepared BIP-18 proposal using the emergencyCommit function. This immediately transferred all funds (over $180 million) to the attacker.  4) The attacker then repaid the flash loans, kept $76 million in ETH, and sent the rest to Tornado Cash.  The key factors that enabled this attack were:  - Lack of a delay in executing governance proposals - Ability to temporarily gain voting power via flash loans - Emergency commit functionality that allowed instant execution  The report does provide enough technical details to determine how the attack took place through the vulnerabilities described above. Let me know if you need any clarification or have additional questions!",Lack of delay in executing proposals; Flash loans enabling temporary vote manipulation; Emergency proposal execution
bearn-rekt,SUCCESS," Based on the details provided, the vulnerability that enabled the attacker to exploit bEarnFi's BvaultsBank contract was an inconsistency in how the withdraw logic interpreted asset denominations between the BvaultsBank contract and its associated BvaultsStrategy contract.  Specifically:  - BvaultsBank's withdraw logic assumed withdrawn amounts were denominated in BUSD - BvaultsStrategy's withdraw logic assumed withdrawn amounts were denominated in ibBUSD - ibBUSD is an interest-bearing token that is more valuable than BUSD  This meant that when the attacker withdrew BUSD from BvaultsBank, BvaultsStrategy interpreted that as a larger ibBUSD withdrawal. This allowed the attacker to repeatedly deposit and withdraw to accumulate more assets than they deposited, until draining the pool.  The technical steps the attacker took were:  1. Borrow BUSD flash loan 2. Deposit into BvaultsBank (sent to BvaultsStrategy and yield farm) 3. Withdraw BUSD from BvaultsBank (treated by BvaultsStrategy as larger ibBUSD withdrawal) 4. Repeat deposit/withdraw to accumulate credits 5. Drain the pool 6. Return flash loan  So in summary, the root cause was the inconsistency in asset denomination handling between the two contracts, which the attacker was able to exploit through flash loans and repeated deposits/withdrawals.",Inconsistent asset denomination logic between BvaultsBank and BvaultsStrategy allowing exploitative withdrawals
bnb-bridge-rekt,SUCCESS," Based on the details provided, the attacker exploited a vulnerability in the way the Binance Bridge verified proofs from the Binance Beacon Chain. Specifically:  - The bridge uses ""vulnerable IAVL verification"" which the attacker was able to forge for block 110217401 from August 2020.  - As explained by samczsun, there was a bug that allowed the attacker to forge arbitrary messages by submitting falsified proofs of deposit from the Binance Beacon Chain.  - The attacker used this to forge two messages minting 1 million BNB each to their address.  So in summary, the vulnerability was in the bridge's verification of Beacon Chain proofs, which allowed the attacker to exploit it by forging fake deposit proofs to mint BNB tokens to themselves. The technical details of exactly how the IAVL verification was vulnerable are not provided, but the key issue was the bridge's inability to properly verify the authenticity of Beacon Chain proofs.",Flaw in IAVL verification of Binance Beacon Chain proofs allowing forgery of deposit messages to mint tokens
bonq-rekt,SUCCESS," Based on the details provided, it seems the main vulnerability exploited was the ability for the attacker to manually update the price feed for the wrapped ALBT (WALBT) collateral asset using the Tellor oracle. Specifically:  1. The attacker staked 10 TRB tokens worth about $175 to meet the minimum staking requirement for submitting price updates.  2. The attacker then called the submitValue function of the TellorFlex contract to submit a hugely inflated price for WALBT (50000000000000000000000000000000 according to the report).  3. Because BonqDAO uses the instant reported value from the Tellor oracle rather than a time-averaged price, this immediately updated the collateral value.  4. The attacker then borrowed 100M BEUR stablecoins against just 0.1 WALBT collateral due to the inflated collateral price.  5. In a follow up transaction, the attacker reset the WALBT price extremely low, allowing them to liquidate other users' WALBT collateral for a low cost.  In summary, the main issues were:  - The Tellor oracle allowed the attacker to manually set the price with a small stake rather than using an aggregated price feed.  - BonqDAO trusted the instant price from the oracle without additional validation.  - This allowed the attacker to manipulate the collateral value to exploit the lending protocol.  The report provides clear technical details on how the attack took place via manipulating the Tellor oracle price feed. Let me know if you need any clarification or have additional questions!",Tellor oracle allowing manual price setting with small stake; BonqDAO using instant oracle price without validation
cashio-rekt,SUCCESS," Based on the details provided, the root cause of the vulnerability that enabled the infinite mint attack on Cashio was an incomplete validation system for collateral deposits. Specifically:  - Cashio's contract only validated that collateral token deposits were the same type of tokens held by the contract, but did not validate the "".mint"" field of LP tokens deposited via the saber_swap.arrow contract.  - This allowed the hacker to create a fake root contract and a chain of fake token accounts that would pass the incomplete validation checks.  - The hacker was then able to use their fake tokens as collateral to mint a massive amount of CASH tokens.  So in summary, the lack of proper validation of the collateral token contract's minting mechanism enabled the attack. The hacker exploited this by creating fake token contracts that appeared valid to the incomplete validation logic.",Insufficient validation of collateral token contracts allowing mint of unlimited CASH with fake tokens
cream-rekt-2,SUCCESS," Based on the details provided, the attacker took advantage of a pricing vulnerability in Cream Finance's internal PriceOracleProxy for yUSDVault tokens. Specifically:  1. The attacker manipulated the price of yUSDVault tokens by first redeeming a large amount of yUSDVault for the underlying yUSD, drastically reducing the yUSDVault totalSupply.  2. They then made a small yUSD deposit back into the yUSDVault, which led the PriceOracleProxy to incorrectly increase the price of yUSDVault by around a factor of two.  3. This allowed the attacker to use their now overvalued yUSDVault tokens as collateral on Cream Finance to borrow assets from lending pools and default on the loans.  So in summary, the vulnerability was in the yUSDVault price oracle logic, which did not properly account for sudden large changes in totalSupply when determining the yUSDVault price. This allowed the attacker to artificially inflate their collateral value and drain lending pools.  The write-up provides detailed steps on how the manipulation was executed using flash loans, repeated lending and borrowing, and transfer of funds across two addresses controlled by the attacker.",Price oracle vulnerability not accounting for sudden supply changes enabling collateral value inflation
crema-finance-rekt,SUCCESS," Based on the details provided, the vulnerability that enabled the attack was:  ""The attack was made possible due to faulty owner validation on one of the protocol's accounts storing price tick data. These data are used by Crema to calculate LP fees.  The hacker created a false tick account, with fake data, and used flash loans to add liquidity to the protocol. They could then withdraw the liquidity and claim the fees they were "owed" according to their own contract's data.""
